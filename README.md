<div dir="rtl">
 
تمرین شماره ۱: مروری بر اصول شی گرایی (SOLID و اصول طراحی) 

 
   درس: طراحی شی گرای سیستم‌ها (پاییز ۱۴۰۴)

   دانشگاه:
     [دانشگاه شاهد]

   اعضای گروه:
    [ریحانه رمضانیان مقدم] 

   استاد درس: 
    [دکتر پورسلطانی]


([[[[لینک GitHub](https://github.com/reyhanehramezanian/Exercise-number-1---.git)]]])


۱. گام اول: افزودن قابلیت‌های جدید (بدون رعایت OOD)

در این گام، دو قابلیت جدید به سیستم رزرو هتل اضافه شد. این تغییرات بدون در نظر گرفتن اصول شی گرایی (SOLID) و مستقیماً در کلاس‌های اصلی و مرکزی پروژه اعمال شدند.


|ردیف | کلاس تغییر یافته (پرداخت) | توضیح درمورد تغییر | کلاس تغییر یافته (اعلان) | توضیح درمورد تغییر |
|:---:|:---:|:---:|:---:|:---:|
|1|PaymentProcessor.java|افزودن متد payOnSite برای پرداخت حضوری.|SmsSender.java|افزودن کلاس جدید برای پیاده‌سازی متد ارسال پیامک.|
|2|ReservationService.java|افزودن case ONSITE به بلوک switch برای فراخوانی متد payOnSite.|ReservationService.java|افزودن case SMS به بلوک switch برای ایجاد نمونه‌ی SmsSender و ارسال پیامک.|


۲. گام دوم: تحلیل اصول شی گرایی در کد اولیه

بر اساس کدهای تغییر یافته در گام اول، تحلیل اصول SOLID و اصول طراحی در سیستم به شرح زیر است. تمامی نقض‌های اصلی در کلاس ReservationService متمرکز هستند. 


| ردیف | اصل | مورد برقراری / نقض | کلاس | علت برقراری / نقض |
|:---:|:---:|:---:|:---:|:---:|
|1 | اصل SRP | مورد برقراری | - | - |
|2 | اصل SRP | مورد نقض | ReservationService |کلاس بیش از یک مسئولیت دارد: ۱. مدیریت منطق رزرو، ۲. مدیریت فرآیند پرداخت و ۳. مدیریت فرآیند اطلاع‌رسانی.|
|3 | اصل OCP | مورد برقراری | - | - |
|4 | اصل OCP | مورد نقض | ReservationService |برای افزودن هر روش پرداخت یا اعلان جدید، نیاز به تغییر کد در این کلاس وجود دارد.|
|5 | اصل LSP | مورد برقراری | - | - |
|6 | اصل LSP | مورد نقض 1 | SmsSender |پیاده‌سازی sendEmail برای ارسال SMS، رفتار مورد انتظار مشتری از واسط را نقض می‌کند.|
|7 | اصل LSP | مورد نقض 2 | - | - |
|8 | اصل ISP | مورد برقراری | - | - |
|9 | اصل ISP | مورد نقض | Payment Processor |کلاس PaymentProcessor یک "واسط" است که مجبور است تمام متدهای پرداخت را در خود جای دهد، حتی اگر در یک پیاده‌سازی خاص همه آن‌ها نیاز نباشند.|
|10 | اصل DIP | مورد برقراری | - | - |
|11 | اصل DIP | مورد نقض | Reservation Service |ماژول سطح بالا (ReservationService) مستقیماً به جزئیات پیاده‌سازی (مانند EmailSender و PaymentProcessor) وابسته است و نمونه‌سازی (Instantiation) را خودش انجام می‌دهد.|
|12 | اصل PLK | مورد برقراری | - | - |
|13 | اصل PLK | مورد نقض | ReservationService |کلاس برای دسترسی به اطلاعات، از زنجیره فراخوانی (مثلاً res.customer.email) استفاده می‌کند و بیش از حد از ساختار داخلی اشیای مرتبط آگاهی دارد.|
|14 | اصل CRP | مورد برقراری | - |  - |
|15 | اصل CRP | مورد نقض| PaymentProcessor و ReservationService|این دو کلاس که با هم تغییر نمی‌کنند، در یک پکیج قرار دارند و تغییر در یکی (مثلاً افزودن متد payOnSite) مستلزم بازنگری/توزیع مجدد دیگری است.|



۳. گام سوم: رفع موارد نقض اصول شی گرایی

موارد نقض شناسایی شده در گام دوم، با استفاده از الگوهای طراحی و اصول SOLID (به ویژه DIP و OCP) رفع گردیدند. 

اقدامات انجام شده:

1- تفکیک مسئولیت‌ها (SRP):

    - کلاس PaymentProcessor حذف شد.

    - واسط PaymentMethod تعریف شد (با متد pay).

    - برای هر روش پرداخت، یک کلاس اختصاصی (CardPayment، CashPayment، PayPalPayment، OnSitePayment) ایجاد شد که PaymentMethod را پیاده‌سازی می‌کنند.

    - واسط Notifier تعریف شد (با متد sendNotification).

    - برای هر روش اعلان، یک کلاس اختصاصی (EmailSender، SmsSender) ایجاد شد که Notifier را پیاده‌سازی می‌کنند.

2- رعایت OCP و DIP:

    - کلاس ReservationService بازنویسی شد تا وابستگی‌ها (Payment و Notifier) را به جای ایجاد داخلی، از طریق پارامترهای متد (تزریق وابستگی) دریافت کند.

    - بلوک‌های switch/case از ReservationService حذف شدند و منطق به واسط‌ها منتقل شد.

3- رعایت PLK:

    - برای دسترسی به اطلاعات ضروری، متدهای دسترسی (Getters) مناسب به کلاس‌های مرتبط اضافه شده یا متد ()totalPrice برای محاسبه هزینه مستقیماً فراخوانی شد تا زنجیره فراخوانی‌های طولانی حذف شود.


۴. گام چهارم: ارزیابی
|تعداد تغییرات| تغییرات لازم برای افزودن قابلیت‌های پرداخت حضوری و پیامک |
|:---:|:---:|
|۴ تغییر| تغییرPaymentProcessor   / تغییر ReservationService (پرداخت)/ افزودن   SmsSender / تغییر ReservationService (اعلان)|
|۴ تغییر| افزودن کلاس جدید OnSitePayment (پیاده‌سازی PaymentMethod) / افزودن کلاس جدید SmsSender (پیاده‌سازی Notifier)|
 
نتیجه: با رعایت اصول شی گرایی از ابتدا، تمامی تغییرات در کلاس اصلی ReservationService حذف می‌شدند و هر دو قابلیت جدید با فقط دو تغییر (افزودن دو کلاس جدید) به پروژه اضافه می‌شدند.


۵. گام پنجم: نتیجه‌گیری 

رعایت اصول شی گرایی (SOLID) در ساختار جدید، به‌طور مستقیم قابلیت نگهداری (Maintainability) برنامه را بهبود می‌بخشد:

ثبات و کاهش ریسک خطا (OCP و DIP): با استفاده از واسط‌ها و تزریق وابستگی، هسته سیستم (ReservationService) برای توسعه قابلیت‌های جدید (بسته می‌ماند). این امر نیاز به دستکاری کدهای موجود را حذف کرده و ریسک وارد کردن خطا به بخش‌های تست شده را به صفر می‌رساند.

</div>

آزمون‌پذیری و انعطاف‌پذیری: تفکیک مسئولیت‌ها (SRP) و وابستگی به واسط‌ها، امکان استفاده آسان از اشیای ساختگی (Mock Objects) را فراهم کرده و فرآیند تست واحد را سریع‌تر و قابل اعتمادتر می‌کند.

سادگی در مدیریت: جدا شدن مسئولیت‌های پرداخت و اعلان، کلاس‌ها را کوچک‌تر و تمرکز آن‌ها را بیشتر می‌کند، که درک، اشکال‌زدایی و توسعه بخش‌های مختلف سیستم را آسان می‌سازد.
