<div dir="rtl">
**تمرین شماره ۱: مروری بر اصول شی گرایی (SOLID و اصول طراحی)**
 
درس: طراحی شی گرای سیستم‌ها (پاییز ۱۴۰۴)

دانشگاه: [دانشگاه شاهد]

اعضای گروه:

[ریحانه رمضانیان مقدم] - ([لینک GitHub])

۱. گام اول: افزودن قابلیت‌های جدید (بدون رعایت OOD)

در این گام، دو قابلیت جدید به سیستم رزرو هتل اضافه شد. این تغییرات بدون در نظر گرفتن اصول شی گرایی (SOLID) و مستقیماً در کلاس‌های اصلی و مرکزی پروژه اعمال شدند.

|ردیف | کلاس تغییر یافته (پرداخت) | توضیح درمورد تغییر | کلاس تغییر یافته (اعلان) | توضیح درمورد تغییر |
|:---:|:---:|:---:|:---:|:---:|
|1|PaymentProcessor.java|افزودن متد payOnSite برای پرداخت حضوری.|SmsSender.java|افزودن کلاس جدید برای پیاده‌سازی متد ارسال پیامک.|
|2|ReservationService.java|افزودن case ONSITE به بلوک switch برای فراخوانی متد payOnSite.|ReservationService.java|افزودن case SMS به بلوک switch برای ایجاد نمونه‌ی SmsSender و ارسال پیامک.|


۲. گام دوم: تحلیل اصول شی گرایی در کد اولیه
بر اساس کدهای تغییر یافته در گام اول، تحلیل اصول SOLID و اصول طراحی در سیستم به شرح زیر است. تمامی نقض‌های اصلی در کلاس ReservationService متمرکز هستند. 

| ردیف | اصل | مورد برقراری / نقض | کلاس | علت برقراری / نقض |
|:---:|:---:|:---:|:---:|:---:|
|1 | اصل SRP | مورد برقراری | - | - |
|2 | اصل SRP | مورد نقض | ReservationService |کلاس بیش از یک مسئولیت دارد: ۱. مدیریت منطق رزرو، ۲. مدیریت فرآیند پرداخت و ۳. مدیریت فرآیند اطلاع‌رسانی.|
|3 | اصل OCP | مورد برقراری | - | - |
|4 | اصل OCP | مورد نقض | ReservationService |برای افزودن هر روش پرداخت یا اعلان جدید، نیاز به تغییر کد در این کلاس وجود دارد.|
|5 | اصل LSP | مورد برقراری | Room/Reservation | |
|6 | اصل LSP | مورد نقض 1 | SmsSender |اگر واسط پیام متد sendEmail را الزامی کند، پیاده‌سازی SmsSender با فراخوانی داخلی sendSms انتظار مشتری از رفتار متد را نقض می‌کند.|
|7 | اصل LSP | مورد نقض 2 | - | - |
|8 | اصل ISP | مورد برقراری | - | - |
|9 | اصل ISP | مورد نقض | Payment Processor |کلاس PaymentProcessor یک "واسط" است که مجبور است تمام متدهای پرداخت را در خود جای دهد، حتی اگر در یک پیاده‌سازی خاص همه آن‌ها نیاز نباشند.|
|10 | اصل DIP | مورد برقراری | - | - |
|11 | اصل DIP | مورد نقض | Reservation Service |ماژول سطح بالا (ReservationService) مستقیماً به جزئیات پیاده‌سازی (مانند EmailSender و PaymentProcessor) وابسته است و نمونه‌سازی (Instantiation) را خودش انجام می‌دهد.|
|12 | اصل PLK | مورد برقراری | - | - |
|13 | اصل PLK | مورد نقض | ReservationService |کلاس برای دسترسی به اطلاعات، از زنجیره فراخوانی (مثلاً res.customer.email) استفاده می‌کند و بیش از حد از ساختار داخلی اشیای مرتبط آگاهی دارد.|
|14 | اصل CRP | مورد برقراری | - |  - |
|15 | اصل CRP | مورد نقض| PaymentProcessor و ReservationService|این دو کلاس که با هم تغییر نمی‌کنند، در یک پکیج قرار دارند و تغییر در یکی (مثلاً افزودن متد payOnSite) مستلزم بازنگری/توزیع مجدد دیگری است.|

۴. گام چهارم: ارزیابی
|تعداد تغییرات|تغییرات لازم برای افزودن قابلیت‌های پرداخت حضوری و پیامک|
|:---:|:---|
|۴ تغییر|۴ تغییر: ۱. تغییر PaymentProcessor ۲. تغییر ReservationService (پرداخت) ۳. افزودن SmsSender ۴. تغییر ReservationService (اعلان)|
|۴ تغییر|۲ تغییر: ۱. افزودن کلاس جدید OnSitePayment (پیاده‌سازی PaymentMethod) ۲. افزودن کلاس جدید SmsSender (پیاده‌سازی Notifier)|
 
نتیجه: با رعایت اصول شی گرایی از ابتدا، تمامی تغییرات در کلاس اصلی ReservationService حذف می‌شدند و هر دو قابلیت جدید با فقط دو تغییر (افزودن دو کلاس جدید) به پروژه اضافه می‌شدند.


۵. گام پنجم: نتیجه‌گیری 

رعایت اصول شی گرایی (SOLID) در ساختار جدید، به‌طور مستقیم قابلیت نگهداری (Maintainability) برنامه را بهبود می‌بخشد:

ثبات و کاهش ریسک خطا (OCP و DIP): با استفاده از واسط‌ها و تزریق وابستگی، هسته سیستم (ReservationService) برای توسعه قابلیت‌های جدید (بسته می‌ماند). این امر نیاز به دستکاری کدهای موجود را حذف کرده و ریسک وارد کردن خطا به بخش‌های تست شده را به صفر می‌رساند.

</div>

آزمون‌پذیری و انعطاف‌پذیری: تفکیک مسئولیت‌ها (SRP) و وابستگی به واسط‌ها، امکان استفاده آسان از اشیای ساختگی (Mock Objects) را فراهم کرده و فرآیند تست واحد را سریع‌تر و قابل اعتمادتر می‌کند.

سادگی در مدیریت: جدا شدن مسئولیت‌های پرداخت و اعلان، کلاس‌ها را کوچک‌تر و تمرکز آن‌ها را بیشتر می‌کند، که درک، اشکال‌زدایی و توسعه بخش‌های مختلف سیستم را آسان می‌سازد.
