تمرین شماره ۱: مروری بر اصول شی گرایی (SOLID و اصول طراحی)
درس: طراحی شی گرای سیستم‌ها (پاییز ۱۴۰۴)

دانشگاه: [دانشگاه شاهد]

اعضای گروه:

[ریحانه رمضانیان مقدم] - ([لینک GitHub])

۱. گام اول: افزودن قابلیت‌های جدید (بدون رعایت OOD)

در این گام، دو قابلیت جدید به سیستم رزرو هتل اضافه شد. این تغییرات بدون در نظر گرفتن اصول شی گرایی (SOLID) و مستقیماً در کلاس‌های اصلی و مرکزی پروژه اعمال شدند.

|ردیف | کلاس تغییر یافته (پرداخت) | توضیح درمورد تغییر | کلاس تغییر یافته (اعلان) | توضیح درمورد تغییر |
|:---:|:---:|:---:|:---:|:---:|
|1|PaymentProcessor.java|افزودن متد payOnSite برای پرداخت حضوری.|SmsSender.java|افزودن کلاس جدید برای پیاده‌سازی متد ارسال پیامک.|
|2|ReservationService.java|افزودن case ONSITE به بلوک switch برای فراخوانی متد payOnSite.|ReservationService.java|افزودن case SMS به بلوک switch برای ایجاد نمونه‌ی SmsSender و ارسال پیامک.|


۲. گام دوم: تحلیل اصول شی گرایی در کد اولیه
بر اساس کدهای تغییر یافته در گام اول، تحلیل اصول SOLID و اصول طراحی در سیستم به شرح زیر است. تمامی نقض‌های اصلی در کلاس ReservationService متمرکز هستند. 

| ردیف | اصل | مورد برقراری / نقض | کلاس | علت برقراری / نقض |
|:---:|:---:|:---:|:---:|:---:|
|1 | اصل SRP | مورد برقراری | - | - |
|2 | اصل SRP | مورد نقض | ReservationService |کلاس بیش از یک مسئولیت دارد: ۱. مدیریت منطق رزرو، ۲. مدیریت فرآیند پرداخت و ۳. مدیریت فرآیند اطلاع‌رسانی.|
|3 | اصل OCP | مورد برقراری | - | - |
|4 | اصل OCP | مورد نقض | ReservationService |برای افزودن هر روش پرداخت یا اعلان جدید، نیاز به تغییر کد در این کلاس وجود دارد.|
|5 | اصل LSP | مورد برقراری | Room/Reservation | |
|6 | اصل LSP | مورد نقض 1 | SmsSender |اگر واسط پیام متد sendEmail را الزامی کند، پیاده‌سازی SmsSender با فراخوانی داخلی sendSms انتظار مشتری از رفتار متد را نقض می‌کند.|
|7 | اصل LSP | مورد نقض 2 | - | - |
|8 | اصل ISP | مورد برقراری | - | - |
|9 | اصل ISP | مورد نقض | Payment Processor | کلاس PaymentProcessor یک "واسط" است که مجبور است تمام متدهای پرداخت را در خود جای دهد، حتی اگر در یک پیاده‌سازی خاص همه آن‌ها نیاز نباشند.|
|10 | اصل DIP | مورد برقراری | - | - |
|11 | اصل DIP | مورد نقض | Reservation Service | ماژول سطح بالا (ReservationService) مستقیماً به جزئیات پیاده‌سازی (مانند EmailSender و PaymentProcessor) وابسته است و نمونه‌سازی (Instantiation) را خودش انجام می‌دهد.|
|12 | اصل PLK | مورد برقراری | - | - |
|13 | اصل PLK | مورد نقض | ReservationService |کلاس برای دسترسی به اطلاعات، از زنجیره فراخوانی (مثلاً res.customer.email) استفاده می‌کند و بیش از حد از ساختار داخلی اشیای مرتبط آگاهی دارد.|
|14 | اصل CRP | مورد برقراری | - |  - |
|15 | اصل CRP | مورد نقض| PaymentProcessor و ReservationService| این دو کلاس که با هم تغییر نمی‌کنند، در یک پکیج قرار دارند و تغییر در یکی (مثلاً افزودن متد payOnSite) مستلزم بازنگری/توزیع مجدد دیگری است.|

گام چهارم (ارزیابی)

الف. تغییرات حذف شده (حذف بلوک‌های switch/case)
در صورتی که اصول شی گرایی از ابتدا (با استفاده از واسط‌ها و تزریق وابستگی) رعایت می‌شد، تمامی تغییرات زیر در کلاس ReservationService که برای افزودن دو قابلیت (پرداخت حضوری و پیامک) در گام اول ضروری بودند، حذف می‌شدند:

1- حذف یک تغییر: افزودن case ONSITE به بلوک switch برای انتخاب روش پرداخت.

2- حذف یک تغییر: افزودن case SMS به بلوک switch برای انتخاب روش ارسال پیام.

ب. تعداد تغییرات برای افزودن قابلیت‌ها
با رعایت اصول شی گرایی (ساختار گام سوم)، این دو قابلیت تنها با دو تغییر (کلاس/فایل جدید) و بدون تغییر در کلاس اصلی ReservationService به پروژه اضافه می‌شدند:

افزودن کلاس جدید OnSitePayment.java (پیاده‌سازی واسط PaymentMethod).

افزودن کلاس جدید SmsSender.java (پیاده‌سازی واسط Notifier).

نتیجه: در مجموع دو تغییر در کلاس ReservationService حذف می‌شدند و این دو قابلیت با دو تغییر (دو کلاس جدید) به پروژه اضافه می‌شدند.

گام پنجم (نتیجه گیری)

رعایت اصول شی گرایی (SOLID) در این برنامه، به‌ویژه با ساختار ایجاد شده در گام سوم (استفاده از واسط‌ها و تزریق وابستگی)، به بهبود قابلیت مراقبت و نگهداری (Maintainability) برنامه به شکل زیر کمک می‌کند:

1- کاهش پیچیدگی و مسئولیت (SRP): با جدا شدن مسئولیت‌های پرداخت و اطلاع‌رسانی از ReservationService، این کلاس کوچک‌تر، قابل فهم‌تر و آسان‌تر برای نگهداری می‌شود. تغییر در یک حوزه (مثلاً پرداخت) بر حوزه دیگر (مثلاً منطق رزرو) تأثیری نمی‌گذارد.

2- آزمون‌پذیری بهتر: از آنجا که ReservationService به پیاده‌سازی‌های واقعی وابسته نیست و به جای آن وابستگی‌ها تزریق می‌شوند، می‌توان به‌راحتی در هنگام تست، از پیاده‌سازی‌های ساختگی (Mock Objects) استفاده کرد. این کار باعث می‌شود تا تست‌های واحد سریع‌تر و مطمئن‌تر باشند.

3- توسعه آسان‌تر و کاهش ریسک خطا (OCP): افزودن قابلیت‌های جدید (مانند روش پرداخت جدید یا واسط اطلاع‌رسانی جدید) بدون نیاز به دستکاری کدهای موجود (مانند ReservationService) انجام می‌شود. این امر ریسک وارد کردن خطا به کدهای قبلاً تست شده را به صفر می‌رساند.

4- انعطاف‌پذیری و ماژولار بودن (DIP): سیستم به‌طور کلی انعطاف‌پذیرتر می‌شود؛ زیرا ماژول‌های سطح بالا به جزئیات پیاده‌سازی وابسته نیستند. این ساختار امکان جایگزینی آسان مؤلفه‌ها (مانند تغییر کتابخانه ارسال ایمیل) را فراهم می‌کند.
