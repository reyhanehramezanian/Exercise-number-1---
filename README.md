| اصل | مورد برقراری / نقض | کلاس | علت برقراری / نقض | 
|:---:|:---:|:---:|:---:|
| اصل SRP | مورد برقراری | - | - |
| اصل SRP | مورد نقض | ReservationService |این کلاس بیش از یک مسئولیت دارد: ۱. مدیریت منطق اصلی رزرو (اعمال تخفیف)، ۲. مدیریت فرآیند پرداخت (انتخاب روش پرداخت)، و ۳. مدیریت فرآیند اطلاع‌رسانی (انتخاب روش ارسال).  |
| اصل OCP | مورد برقراری | - | - |
| اصل OCP | مورد نقض | ReservationService | برای افزودن هر روش پرداخت جدید (مانند پرداخت حضوری) یا هر روش ارسال پیام جدید (مانند پیامک)، باید کلاس ReservationService را تغییر دهیم (اضافه کردن case در بلوک‌های switch/case). |
| اصل LSP | مورد برقراری | Room/Reservation | کلاس‌ها ساده بوده و وراثت پیچیده‌ای ندارند که باعث نقض این اصل شود. |
| اصل LSP | مورد نقض 1 | SmsSender | در کد اولیه اگر کلاس SmsSender از واسط MessageSender استفاده کرده باشد، و متد واسط دارای نام sendEmail باشد، در حالی که پیاده‌سازی متد sendEmail در SmsSender صرفاً متد sendSms را فراخوانی می‌کند، ممکن است مشتری انتظار یک رفتار مبتنی بر ایمیل را داشته باشد اما رفتار پیامکی دریافت کند. |
| اصل LSP | مورد نقض 2 | - | - |
| اصل ISP | مورد برقراری | - | - |
| اصل ISP | مورد نقض | Message Sender و Payment Processor | Payment Processor به عنوان یک کلاس، تمام متدهای پرداخت (کارت، نقد، پی‌پال، حضوری) را در خود جای داده است. همچنین، اگر واسط Message Sender متد sendEmail را داشته و Sms Sender برای پیاده‌سازی این واسط مجبور به تعریف این متد (با پیاده‌سازی منطق پیامک) باشد، این واسط یک "واسط چاق" (Fat Interface) است و کلاس‌ها را مجبور به وابستگی به متدهایی می‌کند که از آن‌ها استفاده نمی‌کنند. |
| اصل DIP | مورد برقراری | - | - |
| اصل DIP | مورد نقض | Reservation Service | ماژول سطح بالا (منطق اصلی ReservationService) مستقیماً به ماژول‌های سطح پایین (EmailSender، SmsSender و PaymentProcessor) وابسته است و آن‌ها را مستقیماً نمونه‌سازی (Instantiate) می‌کند (مثلاً EmailSender emailSender = new EmailSender();). ماژول‌ها به‌جای وابستگی به واسط‌ها (Abstractions)، به جزئیات (Details) وابسته هستند. |
| اصل PLK | مورد برقراری | - | - |
| اصل PLK | مورد نقض | ReservationService | کلاس ReservationService برای دسترسی به اطلاعات مشتری و اتاق، از طریق شیء Reservation به متغیرها دسترسی پیدا می‌کند (به عنوان مثال: res.customer.city یا res.totalPrice()). این زنجیره فراخوانی (Method Chaining) (مانند res.customer.email) نشان می‌دهد که ReservationService بیش از حد از ساختار داخلی کلاس‌های Reservation، Customer و Room آگاهی دارد و این اصل را نقض می‌کند.  |
| اصل CRP | مورد برقراری | - |  - |
| اصل CRP | مورد نقض| Payment Processor و Reservation Service | PaymentProcessor و ReservationService در یک پکیج قرار دارند. هرگاه روش پرداخت جدیدی اضافه شود (مانند payOnSite)، کلاس PaymentProcessor تغییر می‌کند و این امر باعث می‌شود کلاس ReservationService نیز باید به دلیل وابستگی به آن (یا حداقل نیاز به توزیع مجدد) تغییر کند. عدم تفکیک مناسب ماژول‌هایی که با هم تغییر نمی‌کنند، این اصل را نقض می‌کند. |
