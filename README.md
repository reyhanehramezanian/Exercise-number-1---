تمرین شماره ۱: مروری بر اصول شی گرایی (SOLID و اصول طراحی)
درس: طراحی شی گرای سیستم‌ها (پاییز ۱۴۰۴)

دانشگاه: [دانشگاه شاهد]

اعضای گروه:

[ریحانه رمضانیان مقدم] - ([لینک GitHub])

۱. گام اول: افزودن قابلیت‌های جدید (بدون رعایت OOD)

در این گام، دو قابلیت جدید به سیستم رزرو هتل اضافه شد. این تغییرات بدون در نظر گرفتن اصول شی گرایی (SOLID) و مستقیماً در کلاس‌های اصلی و مرکزی پروژه اعمال شدند.

| ردیف | کلاس تغییر یافته | توضیح درمورد تغییر (پرداخت) | کلاس تغییر یافته (اعلان) | توضیح درمورد تغییر |
|:---:|:---:|:---:|:---:|:---:|
|1|PaymentProcessor.java|افزودن متد payOnSite برای پرداخت حضوری.|SmsSender.java|افزودن کلاس جدید برای پیاده‌سازی متد ارسال پیامک.|
|2|ReservationService.java|افزودن case ONSITE به بلوک switch برای فراخوانی متد payOnSite.|ReservationService.java|افزودن case SMS به بلوک switch برای ایجاد نمونه‌ی SmsSender و ارسال پیامک.|




 
گام دوم (تحلیل اصول شی گرایی)
 
| ردیف | اصل | مورد برقراری / نقض | کلاس | علت برقراری / نقض | 
|:---:|:---:|:---:|:---:|
|1 | اصل SRP | مورد برقراری | - | - |
|2 | اصل SRP | مورد نقض | ReservationService |این کلاس بیش از یک مسئولیت دارد: ۱. مدیریت منطق اصلی رزرو (اعمال تخفیف)، ۲. مدیریت فرآیند پرداخت (انتخاب روش پرداخت)، و ۳. مدیریت فرآیند اطلاع‌رسانی (انتخاب روش ارسال).  |
|3 | اصل OCP | مورد برقراری | - | - |
|4 | اصل OCP | مورد نقض | ReservationService | برای افزودن هر روش پرداخت جدید (مانند پرداخت حضوری) یا هر روش ارسال پیام جدید (مانند پیامک)، باید کلاس ReservationService را تغییر دهیم (اضافه کردن case در بلوک‌های switch/case). |
|5 | اصل LSP | مورد برقراری | Room/Reservation | کلاس‌ها ساده بوده و وراثت پیچیده‌ای ندارند که باعث نقض این اصل شود. |
|6 | اصل LSP | مورد نقض 1 | SmsSender | در کد اولیه اگر کلاس SmsSender از واسط MessageSender استفاده کرده باشد، و متد واسط دارای نام sendEmail باشد، در حالی که پیاده‌سازی متد sendEmail در SmsSender صرفاً متد sendSms را فراخوانی می‌کند، ممکن است مشتری انتظار یک رفتار مبتنی بر ایمیل را داشته باشد اما رفتار پیامکی دریافت کند. |
|7 | اصل LSP | مورد نقض 2 | - | - |
|8 | اصل ISP | مورد برقراری | - | - |
|9 | اصل ISP | مورد نقض | Message Sender و Payment Processor | Payment Processor به عنوان یک کلاس، تمام متدهای پرداخت (کارت، نقد، پی‌پال، حضوری) را در خود جای داده است. همچنین، اگر واسط Message Sender متد sendEmail را داشته و Sms Sender برای پیاده‌سازی این واسط مجبور به تعریف این متد (با پیاده‌سازی منطق پیامک) باشد، این واسط یک "واسط چاق" (Fat Interface) است و کلاس‌ها را مجبور به وابستگی به متدهایی می‌کند که از آن‌ها استفاده نمی‌کنند. |
|10 | اصل DIP | مورد برقراری | - | - |
|11 | اصل DIP | مورد نقض | Reservation Service | ماژول سطح بالا (منطق اصلی ReservationService) مستقیماً به ماژول‌های سطح پایین (EmailSender، SmsSender و PaymentProcessor) وابسته است و آن‌ها را مستقیماً نمونه‌سازی (Instantiate) می‌کند (مثلاً EmailSender emailSender = new EmailSender();). ماژول‌ها به‌جای وابستگی به واسط‌ها (Abstractions)، به جزئیات (Details) وابسته هستند. |
|12 | اصل PLK | مورد برقراری | - | - |
|13 | اصل PLK | مورد نقض | ReservationService | کلاس ReservationService برای دسترسی به اطلاعات مشتری و اتاق، از طریق شیء Reservation به متغیرها دسترسی پیدا می‌کند (به عنوان مثال: res.customer.city یا res.totalPrice()). این زنجیره فراخوانی (Method Chaining) (مانند res.customer.email) نشان می‌دهد که ReservationService بیش از حد از ساختار داخلی کلاس‌های Reservation، Customer و Room آگاهی دارد و این اصل را نقض می‌کند.  |
|14 | اصل CRP | مورد برقراری | - |  - |
|15 | اصل CRP | مورد نقض| Payment Processor و Reservation Service | PaymentProcessor و ReservationService در یک پکیج قرار دارند. هرگاه روش پرداخت جدیدی اضافه شود (مانند payOnSite)، کلاس PaymentProcessor تغییر می‌کند و این امر باعث می‌شود کلاس ReservationService نیز باید به دلیل وابستگی به آن (یا حداقل نیاز به توزیع مجدد) تغییر کند. عدم تفکیک مناسب ماژول‌هایی که با هم تغییر نمی‌کنند، این اصل را نقض می‌کند. |

گام چهارم (ارزیابی)

الف. تغییرات حذف شده (حذف بلوک‌های switch/case)
در صورتی که اصول شی گرایی از ابتدا (با استفاده از واسط‌ها و تزریق وابستگی) رعایت می‌شد، تمامی تغییرات زیر در کلاس ReservationService که برای افزودن دو قابلیت (پرداخت حضوری و پیامک) در گام اول ضروری بودند، حذف می‌شدند:

1- حذف یک تغییر: افزودن case ONSITE به بلوک switch برای انتخاب روش پرداخت.

2- حذف یک تغییر: افزودن case SMS به بلوک switch برای انتخاب روش ارسال پیام.

ب. تعداد تغییرات برای افزودن قابلیت‌ها
با رعایت اصول شی گرایی (ساختار گام سوم)، این دو قابلیت تنها با دو تغییر (کلاس/فایل جدید) و بدون تغییر در کلاس اصلی ReservationService به پروژه اضافه می‌شدند:

افزودن کلاس جدید OnSitePayment.java (پیاده‌سازی واسط PaymentMethod).

افزودن کلاس جدید SmsSender.java (پیاده‌سازی واسط Notifier).

نتیجه: در مجموع دو تغییر در کلاس ReservationService حذف می‌شدند و این دو قابلیت با دو تغییر (دو کلاس جدید) به پروژه اضافه می‌شدند.

گام پنجم (نتیجه گیری)

رعایت اصول شی گرایی (SOLID) در این برنامه، به‌ویژه با ساختار ایجاد شده در گام سوم (استفاده از واسط‌ها و تزریق وابستگی)، به بهبود قابلیت مراقبت و نگهداری (Maintainability) برنامه به شکل زیر کمک می‌کند:

1- کاهش پیچیدگی و مسئولیت (SRP): با جدا شدن مسئولیت‌های پرداخت و اطلاع‌رسانی از ReservationService، این کلاس کوچک‌تر، قابل فهم‌تر و آسان‌تر برای نگهداری می‌شود. تغییر در یک حوزه (مثلاً پرداخت) بر حوزه دیگر (مثلاً منطق رزرو) تأثیری نمی‌گذارد.

2- آزمون‌پذیری بهتر: از آنجا که ReservationService به پیاده‌سازی‌های واقعی وابسته نیست و به جای آن وابستگی‌ها تزریق می‌شوند، می‌توان به‌راحتی در هنگام تست، از پیاده‌سازی‌های ساختگی (Mock Objects) استفاده کرد. این کار باعث می‌شود تا تست‌های واحد سریع‌تر و مطمئن‌تر باشند.

3- توسعه آسان‌تر و کاهش ریسک خطا (OCP): افزودن قابلیت‌های جدید (مانند روش پرداخت جدید یا واسط اطلاع‌رسانی جدید) بدون نیاز به دستکاری کدهای موجود (مانند ReservationService) انجام می‌شود. این امر ریسک وارد کردن خطا به کدهای قبلاً تست شده را به صفر می‌رساند.

4- انعطاف‌پذیری و ماژولار بودن (DIP): سیستم به‌طور کلی انعطاف‌پذیرتر می‌شود؛ زیرا ماژول‌های سطح بالا به جزئیات پیاده‌سازی وابسته نیستند. این ساختار امکان جایگزینی آسان مؤلفه‌ها (مانند تغییر کتابخانه ارسال ایمیل) را فراهم می‌کند.
